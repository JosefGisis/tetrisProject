This is the code for my first official Python project. It is a bare-bones tetris style game.
- Josef Gisis 9/8/2023

Surface images for tetris pieces and destroyed lines created by Josef Gisis

Background image designed by rawpixel.com / Freepik

________________________________________________________________________________________________________________________

DEVELOPEMENT INFORMATION

    ____________________________________________________________________________________________________________________
    A) Game requirements:

    Start_menu:
    >	Start game.
    >	Options.
    >	Help.
    >	Credit and development information.
    >	(optional) starting difficulty level.
    >	Exit.

    Play_surface_setup:
    >	Play surface grid 10 squares wide by 20 squares tall (each grid will probably be 36 pixels square).
    >	Scoreboard with enough space to keep score, high score, level, and lines erased.
    >	Surface to display next tetromino.

    Game_loop:
    >	When the player starts a new game...
    >	And while the player has not lost the game...
    >	A random assortment of tetrominos are projected onto the play surface.
    >	When the user presses the right arrow key and the left arrow key, the tetromino moves to the right and left
        respectively.
    >	The tetromino moves as long as the move keys are held down.
    >	The A key rotates the tetromino counterclockwise.
    >	The D key rotates the tetromino clockwise.
    >	Rotation has no hold-down key feature.
    >   One key speeds up the descent of the tetromino.
    >   The ESC key brings up the pause menu.
    >   (optional) A continuous loop of music plays in the background, and music may change as the game level increases.
    >   Points are accumulated and displayed on the scoreboard.

    Pause_menu:
    >	Resume option.
    >	Start new game >>> call new game module.
    >	Options.
    >	Help.
    >	Credit and development information.
    >	(optional) Mute sound (?).
    >	Exit to main menu.

    Tetrominoes:
    >	Seven distinct tetromino pieces each comprised of four segments:
       a.	O piece
       b.	I piece
       c.	S piece
       d.	Z piece
       e.	L piece
       f.	J piece
       g.	T piece
    >	Seven aforementioned pieces need to be generated randomly and displayed on the play surface.
    >	Each shape has its own color.
    >	2x3 pieces first start descending on the 4th to the 7th segment of the top row.
    >	1x4 pieces first start descending on the 4th to the 8th segment of the top row.
    >	Pieces need to move downward at a constant rate that is determined by grid size.
    >	Pieces need to be able to move left and right one grid at a time.
    >	The drop rate will accelerate as the user reaches higher levels.
    >	Each piece (other than O) needs to be able to rotate in a clockwise and/or counterclockwise direction.
    >	2x3 pieces rotation:
        a.	2x3 pieces rotate within a 3x3.
        b.	On a clockwise rotation the piece moves from the top two rows to the two right columns.
        c.	On another clockwise rotation, the piece takes up the bottom two rows.
        d.	The piece is upside down (this does not matter with the s and z piece which look the same).
        e.	On another clockwise rotation the piece moves from the bottom two rows to the two left columns.
        f.	And another clockwise rotation sets the piece into its original position at the top two rows.
        g.	The same happens in reverse when the user turns the piece counterclockwise.
    >	1x4 piece rotation:
        a.	A 1x4 piece rotates in a four-by-four block (making a plus sign four squares high by four squares tall).
        b.	On a clockwise rotation, the piece goes from the second-to-top row, to the second-to-right column, to the
            second to bottom row, to the second-to-left column, and back to the second-to-top row.
    >	Pieces need to have the ability to drop at a faster rate.
    >	(optional) Pieces need to have the ability to drop instantaneously.
    >	Pieces need to come to rest when they reach the bottom or hit the top of another piece, whichever comes first.
    >	When said piece comes to a stop, all four segment need to come to a rest regardless of whether they have come to
        rest on a segment beneath them.
    >	Pieces may still be moved and rotated briefly after they have come into contact with the bottom of the play
        board or the top of another piece.
    >   Each tetromino can be rotated to four different positions (0, 90, 180, and 270) and each position can be reached
        through a clockwise or counterclockwise spin.
    >   If any tetromino is blocked after rotation, the tetromino is tested at four locations (wallkick).
    >   The first location available is where the tetromino will come to rest. And if none of the moves are available,
        the rotation is blocked.
    >   The I piece has a different wallkick than the other tetrominos.
    >	Pieces need to be accounted as four separate segments (the reason for this is explained in the row completion
        requirements segment).
    >	(optional) t pieces need to be able to do a t spin.
    >	All pieces start above the top of the surface.

    Ghost_piece (optional):
    >	During the descent of each tetromino, a semitranslucent tetromino (or an outline) – identical in shape,
        position, and orientation – mimics the falling tetromino.
    >	While the play surface is clear beneath the falling tetromino (that is in its current x position), the ghost
        piece will move along the bottom of the play surface, imitating the piece's final position (given it does not
        move, or rotate).
    >	While the play surface beneath the falling tetrominoes is filled, the ghost piece glides along the tops of the
        fallen pieces mimicking the falling tetromino's final position.

    Row_completion:
    >	Row completion detection keeps track of all twenty rows to see if they have been filled.
    >	Each tetromino segment needs to be attributed to each segment of the playboard (200 segments).
    >	When one row is filled up, all the segment are destroyed, and the above pieces drop down, and an animation is
        called.
    >	When four rows are filled at once, the player receives a Tetris, and a special animation is called.
    >	Row completion detection eliminates completed rows, but pieces can be suspended over a gap, if such turns out to
        be the case. Therefor...
    >	It is necessary to program the tetrominoes as four cohesive but independent pieces.

    Next_piece:
    >	Separate from the scoreboard a different window needs to display the next piece.

    Score_counter:
    >	Points should be awarded for each tetromino that reaches the bottom of the play board or the top of another
        tetromino (TBD).
    >	Point should be awarded for accelerated pieces (amount to be determined).
    >	(optional) Points should be awarded for instantaneously dropped tetrominoes (amount to be determined).
    >	Points are awarded for erasing a row (amount to be determined).
    >	The highest number of points are rewarded for performing a tetris.
    >	(optional) The highest number of points are rewarded for a t-spin.
    >	Score needs to be kept for the current game, or the “current score”.
    >	The score affect the rate of the game, or level.
    >	High scores need to be kept for the user.

    Game_over :
    >	When the top of any tetromino at its rest exceeds the maximum height of the play surface, the player loses the
        game.
    >	The current score is recorded and compared against the high score.
    >	When the current score beats the high score, the new high score is displayed with the current score, along with
        a message stating “new high score!”.
    >	When the high score is greater than the current score, the current and “high score” are both displayed.
    >	The user is asked if he would like to start a new game >>> call new game.
    >	If not, the user returns to the main menu.

    New_Game:
    >	The current score needs to be cleared.
    >	The current play surface needs to be cleared.

    ____________________________________________________________________________________________________________________

    Information on tetromino rotation functions (see program documentation first):

    Both the clockwise and counterclockwise rotation functions use list comprehension methods to rotate the tetrominos
    ninety degrees at a time. Each tetromino is represented by a letter constant (L_piece, O_PIECE, S_PIECE, Z_PIECE,
    T_PIECE, J_PIECE, and L_PIECE) assigned by a list array (matrix).

    In order to rotate each matrix we can use a list comprehension method to transpose the rows and columns of each
    matrix. For example:
    The tetromino S   [0, 1, 1]    rotates clockwise to    [0, 1, 0]    and counterclockwise to    [1, 0, 0]
                      [1, 1, 0]                            [0, 1, 1]                               [1, 1, 0]
                      [0, 0, 0]                            [0, 0, 1]                               [0, 1, 0]

    Note that when the S pieces is rotated clockwise, the top row become the last column, the middle row becomes the the
    middle column, and the bottom row becomes of the first column. We can use an algorithm to take the contents of each
    row and displays them vertically in ascending order and then reverses the order of each row.

    For example:   [0, 1, 1]   to   [0, 1, 0]   to   [0, 1, 0]   by reversing each row in the second matrix.
                   [1, 1, 0]        [1, 1, 0]        [0, 1, 1]
                   [0, 0, 0]        [1, 0, 0]        [0, 0, 1]

    The code may go something like this (using Python).

    matrix = [[0, 1, 0],
              [1, 1, 0],
              [0, 0, 0]]

    for row in matrix:
        print(row)

    new_matrix = [[0, 0, 0],
                  [0, 0, 0],
                  [0, 0, 0]]

    for row in range(len(matrix)):
        for column in range(len(matrix[row])):
            new_matrix[column][row] = matrix[row][column]
    for row in new_matrix:
        row.reverse()

    print()
    for row in new_matrix:
        print(row)

    This is a very basic idea of the logic. The reader may note: in order to rotate this matrix counterclockwise, rather
    than reverse the order of each row, reverse the list itself (or put differently, reverse the order of the columns).
    The reader may take the above code, and see how it behaves with different shapes and with grids of different sizes.

    Python offers a very powerful and quick list comprehension method that goes as such:

    new_list = [perform x expression >>> for objects in old_list >>> while x condition is met]

    We can use list comprehension to rotate matrices:

    matrix = [[0, 1, 0],
              [1, 1, 0],
              [0, 0, 0]]

    for row in matrix:
        print(row)

    new_matrix = [[matrix[column][row] for column in range(len(matrix[row]))] for row in range(len(matrix))]
    for row in new_matrix:
        row.reverse()

    print()
    for row in new_matrix:
        print(row)

    The tetris game does not just display matrices; rather, a generate piece function creates segment objects by
    checking the contents of the matrix. When a tetromino is flipped a rotate function is called that takes the current
    matrix in use, say L, and rotates the matrix. Then a new tetromino is creates by generating a new piece using the
    rotated matrix. In the program the code looks like this:

    def cw_rotation():
    global current_letter, rotation_state, startx, starty
    blocked = False
    if current_letter != O_PIECE and moving < delay:
        rotated_letter = [[current_letter[j][i] for j in range(len(current_letter))]
                          for i in range(len(current_letter[0]))]
        for list in rotated_letter:
            list.reverse()
        gen_tetro(rotated_letter, current_surface)

    After each tetromino is rotated, the function checks if the piece has collided with other dropped segments. If it
    has, each tetromino is tested in multiple location and set in the first available space. If all spaces are taken
    the rotation is cancelled. Here is the full clockwise rotation function:

    def cw_rotation():
    global current_letter, rotation_state, startx, starty
    blocked = False
    if current_letter != O_PIECE and moving < delay:
        rotated_letter = [[current_letter[j][i] for j in range(len(current_letter))]
                          for i in range(len(current_letter[0]))]
        for list in rotated_letter:
            list.reverse()
        gen_tetro(rotated_letter, current_surface)
        if move_blocked(0, 0):
            if len(current_letter) < len(I_PIECE):
                for i in range(len(cw_check)):
                    if i == rotation_state:
                        for j in range(len(cw_check[i])):
                            for segment in current_tetro:
                                segment.rect.left += (cw_check[i][j][0] * segment_size)
                                segment.rect.top -= (cw_check[i][j][1] * segment_size)
                            startx += (cw_check[i][j][0] * segment_size)
                            starty -= (cw_check[i][j][1] * segment_size)
                            if move_blocked(0, 0):
                                blocked = True
                            else:
                                blocked = False
                                break
            else:
                for i in range(len(cw_ipiece_check)):
                    if i == rotation_state:
                        for j in range(len(cw_ipiece_check[i])):
                            for segment in current_tetro:
                                segment.rect.left += (cw_ipiece_check[i][j][0] * segment_size)
                                segment.rect.top -= (cw_ipiece_check[i][j][1] * segment_size)
                            startx += (cw_ipiece_check[i][j][0] * segment_size)
                            starty -= (cw_ipiece_check[i][j][1] * segment_size)
                            if move_blocked(0, 0):
                                blocked = True
                            else:
                                blocked = False
                                break


        if not blocked:
            current_letter = rotated_letter
            if rotation_state < 3:
                rotation_state += 1
            else:
                rotation_state = 0
        else:
            gen_tetro(current_letter, current_surface)

    Note: many of the global variables would be better handled as class attributes; however, because each square is part
    of the Square class (see program), the tetrominos need to be manipulated through a sprite group.

    The first test is done after the first rotation. If the tetromino is blocked, the function first checks if the
    current tetromino is the I piece. This is because the I piece is tested differently due to its length. Then the
    function checks the rotation state. Rotation state refers to the degree of rotation of each piece (0, 90, 180, and
    270). Depending on the degree of rotation, different tests are performed because certain collisions are more likely
    to occur at different angles of rotation. Furthermore, depending if the piece is rotating clockwise or
    counterclockwise, different test are performed. Because this is the clockwise rotation function, we only need to
    check for ascending degrees of rotation (e.g. 0 to 90 or 270 to 0). These degrees of rotation are referred to as 0
    for 0 degrees, 1 for 90 degrees, 2 for 180 degrees, etc.

    The i variable controls the current rotation state and applies the correct tests. The j variable iterates through
    all the tests. The function finds the rotational state through the i variable, and iterates through a list of test
    moves to find the first available spot (eg. cw_check[i][j][0]). If a spot is found, blocked is set to False and the
    rotational state is updated. If no spot is available, the tetromino is set back to its original position (found at
    the last location in the test move list) and a non rotated piece is regenerated (that is the rotation is cancelled).

    There are several options to set the test location. The first is to use the official Tetris guidelines, the Super
    Rotation System.

    Test moves for the s, z, t, l, and j pieces:

            Test 1	Test 2	Test 3	Test 4	Test 5
    0 >> 1	(0, 0)	(-1, 0)	(-1, 1)	(0,-2)	(-1,-2)
    1 >> 0	(0, 0)	(1, 0)	(1,-1)	(0, 2)	(1, 2)
    1 >> 2	(0, 0)	(1, 0)	(1,-1)	(0, 2)	(1, 2)
    2 >> 1	(0, 0)	(-1, 0)	(-1, 1)	(0,-2)	(-1,-2)
    2 >> 3	(0, 0)	(1, 0)	(1, 1)	(0,-2)	(1,-2)
    3 >> 2	(0, 0)	(-1, 0)	(-1,-1)	(0, 2)	(-1, 2)
    3 >> 0	(0, 0)	(-1, 0)	(-1,-1)	(0, 2)	(-1, 2)
    0 >> 3	(0, 0)	(1, 0)	(1, 1)	(0,-2)	(1,-2)

    Test moves for the i piece:

            Test 1	Test 2	Test 3	Test 4	Test 5
    0 >> 1	(0, 0)	(-2, 0)	(1, 0)	(-2,-1)	(1, 2)
    1 >> 0	(0, 0)	(2, 0)	(-1, 0)	(2, 1)	(-1,-2)
    1 >> 2	(0, 0)	(-1, 0)	(2, 0)	(-1, 2)	(2,-1)
    2 >> 1	(0, 0)	(1, 0)	(-2, 0)	(1,-2)	(-2, 1)
    2 >> 3	(0, 0)	(2, 0)	(-1, 0)	(2, 1)	(-1,-2)
    3 >> 2	(0, 0)	(-2, 0)	(1, 0)	(-2,-1)	(1, 2)
    3 >> 0	(0, 0)	(1, 0)	(-2, 0)	(1,-2)	(-2, 1)
    0 >> 3	(0, 0)	(-1, 0)	(2, 0)	(-1, 2)	(2, -1)

    The numbers refers to x and y movements (e.g. 1 means one horizontal shift to the right). Each move is relative to
    the tetrominos original location. In order to undo each prior test the list needs to be modified.

    Here are four lists for clockwise rotations, counterclockwise rotations, clockwise rotations for i piece, and
    counterclockwise rotations for i piece. The last entry for each sublist is for returning the piece to its original
    location if it fails rotation.

    cw_check = [[[-1, 0], [0, 1], [1, -3], [-1, 0], [1, 2]], [[1, 0], [0, -1], [-1, 3], [1, 0], [-1, -2]],
                [[1, 0], [0, 1], [-1, -3], [1, 0], [-1, 2]], [[-1, 0], [0, -1], [1, 3], [-1, 0], [1, -2]]]

    cw_lpiece_check = [[[-2, 0], [3, 0], [-3, -1], [3, 3], [-1, -2]], [[-1, 0], [3, 0], [-3, 2], [3, -3], [-2, 1]],
                       [[2, 0], [-3, 0], [3, 1], [-3, -3], [1, 2]], [[1, 0], [-3, 0], [3, -2], [-3, 3], [2, -1]]]

    ccw_check = [[[1, 0], [0, 1], [-1, -3], [1, 0], [-1, 2]], [[1, 0], [0, -1], [-1, 3], [1, 0], [-1, -2]],
                 [[-1, 0], [0, 1], [1, -3], [-1, 0], [1, 2]], [[-1, 0], [0, -1], [1, 3], [-1, 0], [1, -2]]]

    ccw_lpiece_check = [[[-1, 0], [3, 0], [-3, 2], [3, -3], [-2, 1]], [[2, 0], [-3, 0], [3, 1], [-3, -3], [1, 2]],
                        [[1, 0], [-3, 0], [3, -2], [-3, 3], [2, -1]], [[-2, 0], [3, 0], [-3, -1], [3, 3], [-1, -2]]]

    The issue with these lists is that when they are implemented, tetrominos bounced of the bottom of the floor of the
    play surface shift left or right (they do not spin in place). Here is an altered list:

    cw_check = [[[0, 1], [-1, 0], [1, -3], [-1, 0], [1, 2]], [[1, 0], [0, -1], [-1, 3], [1, 0], [-1, -2]],
            [[1, 0], [0, 1], [-1, -3], [1, 0], [-1, 2]], [[-1, 0], [0, -1], [1, 3], [-1, 0], [1, -2]]]

    cw_ipiece_check = [[[0, 2], [1, -2], [-3, -1], [3, 3], [-1, -2]], [[-1, 0], [3, 0], [-3, 2], [3, -3], [-2, 1]],
                       [[2, 0], [-3, 0], [3, 1], [-3, -3], [1, 2]], [[1, 0], [-3, 0], [3, -2], [-3, 3], [2, -1]]]

    ccw_check = [[[0, 1], [1, 0], [-1, -3], [1, 0], [-1, 2]], [[1, 0], [0, -1], [-1, 3], [1, 0], [-1, -2]],
                 [[-1, 0], [0, 1], [1, -3], [-1, 0], [1, 2]], [[-1, 0], [0, -1], [1, 3], [-1, 0], [1, -2]]]

    ccw_ipiece_check = [[[0, 2], [-1, -2], [0, 2], [3, -3], [-2, 1]], [[2, 0], [-3, 0], [3, 1], [-3, -3], [1, 2]],
                        [[1, 0], [-3, 0], [3, -2], [-3, 3], [2, -1]], [[-2, 0], [3, 0], [-3, -1], [3, 3], [-1, -2]]]

    Note the changes in the first list in each list. Continued testing required to find the optimal rotation tests.

    Or a simpler version:

    cw_check = [[[0, 1], [-1, -1], [2, 0], [-1, -1], [0, 1]], [[1, 0], [-1, 1], [0, -2], [-1, 1], [1, 0]],
                [[0, -1], [1, 1], [-2, 0], [1, 1], [0, -1]], [[-1, 0], [1, -1], [0, 2], [1, -1], [-1, 0]]]

    cw_ipiece_check = [[[0, 2], [-1, -2], [3, 0], [-2, -1], [0, 1]], [[2, 0], [-2, 1], [0, -3], [-1, 2], [1, 0]],
                       [[0, -2], [1, 2], [-3, 0], [2, 1], [0, -1]], [[-2, 0], [2, -1], [0, 3], [1, -2], [-1, 0]]]

    ccw_check = [[[,], [,], [,], [,], [,]], [[,], [,], [,], [,], [,]],
                 [[,], [,], [,], [,], [,]], [[,], [,], [,], [,], [,]]]

    ccw_ipiece_check = [[[,], [,], [,], [,], [,]], [[,], [,], [,], [,], [,]],
                        [[,], [,], [,], [,], [,]], [[,], [,], [,], [,], [,]]]